<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>JUCE: StreamingSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classStreamingSocket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StreamingSocket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A wrapper for a streaming (TCP) socket.  
 <a href="classStreamingSocket.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a280e9f29da54da9a828c920d734cc580"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a280e9f29da54da9a828c920d734cc580">StreamingSocket</a> ()</td></tr>
<tr class="memdesc:a280e9f29da54da9a828c920d734cc580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised socket.  <a href="#a280e9f29da54da9a828c920d734cc580"></a><br/></td></tr>
<tr class="separator:a280e9f29da54da9a828c920d734cc580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed4b1879a7f212cf95382b418d03210"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#aaed4b1879a7f212cf95382b418d03210">~StreamingSocket</a> ()</td></tr>
<tr class="memdesc:aaed4b1879a7f212cf95382b418d03210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aaed4b1879a7f212cf95382b418d03210"></a><br/></td></tr>
<tr class="separator:aaed4b1879a7f212cf95382b418d03210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0788414f9c3f08d1c5adddf5481e17a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#aa0788414f9c3f08d1c5adddf5481e17a">bindToPort</a> (int localPortNumber)</td></tr>
<tr class="memdesc:aa0788414f9c3f08d1c5adddf5481e17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the socket to the specified local port.  <a href="#aa0788414f9c3f08d1c5adddf5481e17a"></a><br/></td></tr>
<tr class="separator:aa0788414f9c3f08d1c5adddf5481e17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4138f041b6875937b1910a2be0f1b5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#ad4138f041b6875937b1910a2be0f1b5f">getBoundPort</a> () const noexcept</td></tr>
<tr class="memdesc:ad4138f041b6875937b1910a2be0f1b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local port number to which this socket is currently bound.  <a href="#ad4138f041b6875937b1910a2be0f1b5f"></a><br/></td></tr>
<tr class="separator:ad4138f041b6875937b1910a2be0f1b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42934b3f0d68f46f29cc7bb5d1067c33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a42934b3f0d68f46f29cc7bb5d1067c33">connect</a> (const <a class="el" href="classString.html">String</a> &amp;remoteHostname, int remotePortNumber, int timeOutMillisecs=3000)</td></tr>
<tr class="memdesc:a42934b3f0d68f46f29cc7bb5d1067c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to connect the socket to hostname:port.  <a href="#a42934b3f0d68f46f29cc7bb5d1067c33"></a><br/></td></tr>
<tr class="separator:a42934b3f0d68f46f29cc7bb5d1067c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d32e5442ccae9033278729aaa3e075"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a22d32e5442ccae9033278729aaa3e075">isConnected</a> () const noexcept</td></tr>
<tr class="memdesc:a22d32e5442ccae9033278729aaa3e075"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the socket is currently connected.  <a href="#a22d32e5442ccae9033278729aaa3e075"></a><br/></td></tr>
<tr class="separator:a22d32e5442ccae9033278729aaa3e075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ad8b03c9b5ef8572f9b159d3a411d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a59ad8b03c9b5ef8572f9b159d3a411d9">close</a> ()</td></tr>
<tr class="memdesc:a59ad8b03c9b5ef8572f9b159d3a411d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the connection.  <a href="#a59ad8b03c9b5ef8572f9b159d3a411d9"></a><br/></td></tr>
<tr class="separator:a59ad8b03c9b5ef8572f9b159d3a411d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0908b06027d58c1070f5bf1d700959"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classString.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a1f0908b06027d58c1070f5bf1d700959">getHostName</a> () const noexcept</td></tr>
<tr class="memdesc:a1f0908b06027d58c1070f5bf1d700959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the currently connected host.  <a href="#a1f0908b06027d58c1070f5bf1d700959"></a><br/></td></tr>
<tr class="separator:a1f0908b06027d58c1070f5bf1d700959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a413769755ff853ab63a6f27338cce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a27a413769755ff853ab63a6f27338cce">getPort</a> () const noexcept</td></tr>
<tr class="memdesc:a27a413769755ff853ab63a6f27338cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port number that's currently open.  <a href="#a27a413769755ff853ab63a6f27338cce"></a><br/></td></tr>
<tr class="separator:a27a413769755ff853ab63a6f27338cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3da922f5a1bc2d111caa38bd23d2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a47a3da922f5a1bc2d111caa38bd23d2e">isLocal</a> () const noexcept</td></tr>
<tr class="memdesc:a47a3da922f5a1bc2d111caa38bd23d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the socket is connected to this machine rather than over the network.  <a href="#a47a3da922f5a1bc2d111caa38bd23d2e"></a><br/></td></tr>
<tr class="separator:a47a3da922f5a1bc2d111caa38bd23d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809d51655d78f65ee476629b7f1c260"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a4809d51655d78f65ee476629b7f1c260">getRawSocketHandle</a> () const noexcept</td></tr>
<tr class="memdesc:a4809d51655d78f65ee476629b7f1c260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OS's socket handle that's currently open.  <a href="#a4809d51655d78f65ee476629b7f1c260"></a><br/></td></tr>
<tr class="separator:a4809d51655d78f65ee476629b7f1c260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c737d5e12af2540e282d159379163ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a8c737d5e12af2540e282d159379163ba">waitUntilReady</a> (bool readyForReading, int timeoutMsecs) const </td></tr>
<tr class="memdesc:a8c737d5e12af2540e282d159379163ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the socket is ready for reading or writing.  <a href="#a8c737d5e12af2540e282d159379163ba"></a><br/></td></tr>
<tr class="separator:a8c737d5e12af2540e282d159379163ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac048823c044a47600f7f1036c730b934"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#ac048823c044a47600f7f1036c730b934">read</a> (void *destBuffer, int maxBytesToRead, bool blockUntilSpecifiedAmountHasArrived)</td></tr>
<tr class="memdesc:ac048823c044a47600f7f1036c730b934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from the socket.  <a href="#ac048823c044a47600f7f1036c730b934"></a><br/></td></tr>
<tr class="separator:ac048823c044a47600f7f1036c730b934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90721593b92401ecd20aae2c68d3d446"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a90721593b92401ecd20aae2c68d3d446">write</a> (const void *sourceBuffer, int numBytesToWrite)</td></tr>
<tr class="memdesc:a90721593b92401ecd20aae2c68d3d446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes bytes to the socket from a buffer.  <a href="#a90721593b92401ecd20aae2c68d3d446"></a><br/></td></tr>
<tr class="separator:a90721593b92401ecd20aae2c68d3d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd27eafb1f4e3a1bae915e2eb72f41e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#abd27eafb1f4e3a1bae915e2eb72f41e6">createListener</a> (int portNumber, const <a class="el" href="classString.html">String</a> &amp;localHostName=<a class="el" href="classString.html">String</a>())</td></tr>
<tr class="memdesc:abd27eafb1f4e3a1bae915e2eb72f41e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts this socket into "listener" mode.  <a href="#abd27eafb1f4e3a1bae915e2eb72f41e6"></a><br/></td></tr>
<tr class="separator:abd27eafb1f4e3a1bae915e2eb72f41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ed9152008fc7af303330a5e5357990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStreamingSocket.html">StreamingSocket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStreamingSocket.html#a97ed9152008fc7af303330a5e5357990">waitForNextConnection</a> () const </td></tr>
<tr class="memdesc:a97ed9152008fc7af303330a5e5357990"><td class="mdescLeft">&#160;</td><td class="mdescRight">When in "listener" mode, this waits for a connection and spawns it as a new socket.  <a href="#a97ed9152008fc7af303330a5e5357990"></a><br/></td></tr>
<tr class="separator:a97ed9152008fc7af303330a5e5357990"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A wrapper for a streaming (TCP) socket. </p>
<p>This allows low-level use of sockets; for an easier-to-use messaging layer on top of sockets, you could also try the <a class="el" href="classInterprocessConnection.html" title="Manages a simple two-way messaging connection to another process, using either a socket or a named pi...">InterprocessConnection</a> class.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classDatagramSocket.html" title="A wrapper for a datagram (UDP) socket.">DatagramSocket</a>, <a class="el" href="classInterprocessConnection.html" title="Manages a simple two-way messaging connection to another process, using either a socket or a named pi...">InterprocessConnection</a>, <a class="el" href="classInterprocessConnectionServer.html" title="An object that waits for client sockets to connect to a port on this host, and creates InterprocessCo...">InterprocessConnectionServer</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a280e9f29da54da9a828c920d734cc580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamingSocket::StreamingSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialised socket. </p>
<p>To connect it, use the <a class="el" href="classStreamingSocket.html#a42934b3f0d68f46f29cc7bb5d1067c33" title="Tries to connect the socket to hostname:port.">connect()</a> method, after which you can <a class="el" href="classStreamingSocket.html#ac048823c044a47600f7f1036c730b934" title="Reads bytes from the socket.">read()</a> or <a class="el" href="classStreamingSocket.html#a90721593b92401ecd20aae2c68d3d446" title="Writes bytes to the socket from a buffer.">write()</a> to it.</p>
<p>To wait for other sockets to connect to this one, the <a class="el" href="classStreamingSocket.html#abd27eafb1f4e3a1bae915e2eb72f41e6" title="Puts this socket into &quot;listener&quot; mode.">createListener()</a> method enters "listener" mode, and can be used to spawn new sockets for each connection that comes along. </p>

</div>
</div>
<a class="anchor" id="aaed4b1879a7f212cf95382b418d03210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamingSocket::~StreamingSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa0788414f9c3f08d1c5adddf5481e17a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamingSocket::bindToPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localPortNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the socket to the specified local port. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success; false may indicate that another socket is already bound on the same port </dd></dl>

</div>
</div>
<a class="anchor" id="ad4138f041b6875937b1910a2be0f1b5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StreamingSocket::getBoundPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the local port number to which this socket is currently bound. </p>
<p>This is useful if you need to know to which port the OS has actually bound your socket when calling the constructor or bindToPort with zero as the localPortNumber argument. Returns -1 if the function fails. </p>

</div>
</div>
<a class="anchor" id="a42934b3f0d68f46f29cc7bb5d1067c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamingSocket::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteHostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remotePortNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMillisecs</em> = <code>3000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to connect the socket to hostname:port. </p>
<p>If timeOutMillisecs is 0, then this method will block until the operating system rejects the connection (which could take a long time).</p>
<dl class="section return"><dt>Returns</dt><dd>true if it succeeds. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStreamingSocket.html#a22d32e5442ccae9033278729aaa3e075" title="True if the socket is currently connected.">isConnected</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22d32e5442ccae9033278729aaa3e075"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamingSocket::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the socket is currently connected. </p>

</div>
</div>
<a class="anchor" id="a59ad8b03c9b5ef8572f9b159d3a411d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StreamingSocket::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the connection. </p>

</div>
</div>
<a class="anchor" id="a1f0908b06027d58c1070f5bf1d700959"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classString.html">String</a>&amp; StreamingSocket::getHostName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the currently connected host. </p>

</div>
</div>
<a class="anchor" id="a27a413769755ff853ab63a6f27338cce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StreamingSocket::getPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the port number that's currently open. </p>

</div>
</div>
<a class="anchor" id="a47a3da922f5a1bc2d111caa38bd23d2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamingSocket::isLocal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the socket is connected to this machine rather than over the network. </p>

</div>
</div>
<a class="anchor" id="a4809d51655d78f65ee476629b7f1c260"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StreamingSocket::getRawSocketHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the OS's socket handle that's currently open. </p>

</div>
</div>
<a class="anchor" id="a8c737d5e12af2540e282d159379163ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StreamingSocket::waitUntilReady </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readyForReading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMsecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until the socket is ready for reading or writing. </p>
<p>If readyForReading is true, it will wait until the socket is ready for reading; if false, it will wait until it's ready for writing.</p>
<p>If the timeout is &lt; 0, it will wait forever, or else will give up after the specified time.</p>
<p>If the socket is ready on return, this returns 1. If it times-out before the socket becomes ready, it returns 0. If an error occurs, it returns -1. </p>

</div>
</div>
<a class="anchor" id="ac048823c044a47600f7f1036c730b934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StreamingSocket::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBytesToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blockUntilSpecifiedAmountHasArrived</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from the socket. </p>
<p>If blockUntilSpecifiedAmountHasArrived is true, the method will block until maxBytesToRead bytes have been read, (or until an error occurs). If this flag is false, the method will return as much data as is currently available without blocking.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read, or -1 if there was an error. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStreamingSocket.html#a8c737d5e12af2540e282d159379163ba" title="Waits until the socket is ready for reading or writing.">waitUntilReady</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a90721593b92401ecd20aae2c68d3d446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StreamingSocket::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBytesToWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes bytes to the socket from a buffer. </p>
<p>Note that this method will block unless you have checked the socket is ready for writing before calling it (see the <a class="el" href="classStreamingSocket.html#a8c737d5e12af2540e282d159379163ba" title="Waits until the socket is ready for reading or writing.">waitUntilReady()</a> method).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, or -1 if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="abd27eafb1f4e3a1bae915e2eb72f41e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamingSocket::createListener </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>localHostName</em> = <code><a class="el" href="classString.html">String</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts this socket into "listener" mode. </p>
<p>When in this mode, your thread can call <a class="el" href="classStreamingSocket.html#a97ed9152008fc7af303330a5e5357990" title="When in &quot;listener&quot; mode, this waits for a connection and spawns it as a new socket.">waitForNextConnection()</a> repeatedly, which will spawn new sockets for each new connection, so that these can be handled in parallel by other threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portNumber</td><td>the port number to listen on </td></tr>
    <tr><td class="paramname">localHostName</td><td>the interface address to listen on - pass an empty string to listen on all addresses </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it manages to open the socket successfully.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStreamingSocket.html#a97ed9152008fc7af303330a5e5357990" title="When in &quot;listener&quot; mode, this waits for a connection and spawns it as a new socket.">waitForNextConnection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a97ed9152008fc7af303330a5e5357990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStreamingSocket.html">StreamingSocket</a>* StreamingSocket::waitForNextConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When in "listener" mode, this waits for a connection and spawns it as a new socket. </p>
<p>The object that gets returned will be owned by the caller.</p>
<p>This method can only be called after using <a class="el" href="classStreamingSocket.html#abd27eafb1f4e3a1bae915e2eb72f41e6" title="Puts this socket into &quot;listener&quot; mode.">createListener()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStreamingSocket.html#abd27eafb1f4e3a1bae915e2eb72f41e6" title="Puts this socket into &quot;listener&quot; mode.">createListener</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="juce__Socket_8h.html">juce_Socket.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/>
<address class="footer"><small>All content &copy Raw Material Software Ltd.</small></address><br/>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-19759318-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
